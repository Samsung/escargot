diff --git src/binary-reader.cc src/binary-reader.cc
index 9b365e87..d770afa4 100644
--- src/binary-reader.cc
+++ src/binary-reader.cc
@@ -628,7 +628,7 @@ Result BinaryReader::ReadAddress(Address* out_value,
                                  Index memory,
                                  const char* desc) {
   ERROR_UNLESS(memory < memories.size(),
-               "load/store memory %u out of range %lu", memory,
+               "load/store memory %u out of range %zu", memory,
                memories.size());
   if (memories[memory].is_64) {
     return ReadU64Leb128(out_value, desc);
diff --git src/interp/interp-wasm-c-api.cc src/interp/interp-wasm-c-api.cc
index 75190feb..2a0c861d 100644
--- src/interp/interp-wasm-c-api.cc
+++ src/interp/interp-wasm-c-api.cc
@@ -626,6 +626,11 @@ own wasm_store_t* wasm_store_new(wasm_engine_t* engine) {
   return new wasm_store_t(s_features);
 }
 
+void wasm_store_gc(wasm_store_t* store) {
+  assert(store);
+  store->I.Collect();
+}
+
 // wasm_module
 
 own wasm_module_t* wasm_module_new(wasm_store_t* store,
@@ -760,6 +765,20 @@ void wasm_instance_exports(const wasm_instance_t* instance,
   }
 }
 
+uint32_t wasm_instance_func_index(const wasm_instance_t* instance,
+                                const wasm_func_t* func) {
+  auto&& funcs = instance->As<Instance>()->funcs();
+
+  assert(func.size() < wasm_limits_max_default);
+  for (size_t i = 0; i < funcs.size(); ++i) {
+    if (funcs[i] == func->I.ref()) {
+      return i;
+    }
+  }
+
+  return wasm_limits_max_default;
+}
+
 // wasm_functype
 
 own wasm_functype_t* wasm_functype_new(own wasm_valtype_vec_t* params,
@@ -1170,6 +1189,16 @@ void wasm_val_vec_delete(own wasm_val_vec_t* vec) {
     }                                                                   \
     delete[] vec->data;                                                 \
     vec->size = 0;                                                      \
+  }                                                                     \
+  void wasm_##name##_vec_delete_with_size(wasm_##name##_vec_t* vec,     \
+                                          size_t size) {                \
+    assert(size <= vec->size);                                          \
+    TRACE0();                                                           \
+    for (size_t i = 0; i < size; ++i) {                                 \
+      delete vec->data[i];                                              \
+    }                                                                   \
+    delete[] vec->data;                                                 \
+    vec->size = 0;                                                      \
   }
 
 WASM_IMPL_VEC_OWN(frame);
