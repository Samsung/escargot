// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split('/');
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"d": {
		"index.js": function (exports, module, require) {
			'use strict';

			var assign        = require('es5-ext/object/assign')
			  , normalizeOpts = require('es5-ext/object/normalize-options')
			  , isCallable    = require('es5-ext/object/is-callable')
			  , contains      = require('es5-ext/string/#/contains')

			  , d;

			d = module.exports = function (dscr, value/*, options*/) {
				var c, e, w, options, desc;
				if ((arguments.length < 2) || (typeof dscr !== 'string')) {
					options = value;
					value = dscr;
					dscr = null;
				} else {
					options = arguments[2];
				}
				if (dscr == null) {
					c = w = true;
					e = false;
				} else {
					c = contains.call(dscr, 'c');
					e = contains.call(dscr, 'e');
					w = contains.call(dscr, 'w');
				}

				desc = { value: value, configurable: c, enumerable: e, writable: w };
				return !options ? desc : assign(normalizeOpts(options), desc);
			};

			d.gs = function (dscr, get, set/*, options*/) {
				var c, e, options, desc;
				if (typeof dscr !== 'string') {
					options = set;
					set = get;
					get = dscr;
					dscr = null;
				} else {
					options = arguments[3];
				}
				if (get == null) {
					get = undefined;
				} else if (!isCallable(get)) {
					options = get;
					get = set = undefined;
				} else if (set == null) {
					set = undefined;
				} else if (!isCallable(set)) {
					options = set;
					set = undefined;
				}
				if (dscr == null) {
					c = true;
					e = false;
				} else {
					c = contains.call(dscr, 'c');
					e = contains.call(dscr, 'e');
				}

				desc = { get: get, set: set, configurable: c, enumerable: e };
				return !options ? desc : assign(normalizeOpts(options), desc);
			};
		}
	},
	"es5-ext": {
		"global.js": function (exports, module, require) {
			'use strict';

			module.exports = new Function("return this")();
		},
		"object": {
			"assign": {
				"index.js": function (exports, module, require) {
					'use strict';

					module.exports = require('./is-implemented')()
						? Object.assign
						: require('./shim');
				},
				"is-implemented.js": function (exports, module, require) {
					'use strict';

					module.exports = function () {
						var assign = Object.assign, obj;
						if (typeof assign !== 'function') return false;
						obj = { foo: 'raz' };
						assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
						return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
					};
				},
				"shim.js": function (exports, module, require) {
					'use strict';

					var keys  = require('../keys')
					  , value = require('../valid-value')

					  , max = Math.max;

					module.exports = function (dest, src/*, …srcn*/) {
						var error, i, l = max(arguments.length, 2), assign;
						dest = Object(value(dest));
						assign = function (key) {
							try { dest[key] = src[key]; } catch (e) {
								if (!error) error = e;
							}
						};
						for (i = 1; i < l; ++i) {
							src = arguments[i];
							keys(src).forEach(assign);
						}
						if (error !== undefined) throw error;
						return dest;
					};
				}
			},
			"is-callable.js": function (exports, module, require) {
				// Deprecated

				'use strict';

				module.exports = function (obj) { return typeof obj === 'function'; };
			},
			"keys": {
				"index.js": function (exports, module, require) {
					'use strict';

					module.exports = require('./is-implemented')()
						? Object.keys
						: require('./shim');
				},
				"is-implemented.js": function (exports, module, require) {
					'use strict';

					module.exports = function () {
						try {
							Object.keys('primitive');
							return true;
						} catch (e) { return false; }
					};
				},
				"shim.js": function (exports, module, require) {
					'use strict';

					var keys = Object.keys;

					module.exports = function (object) {
						return keys(object == null ? object : Object(object));
					};
				}
			},
			"normalize-options.js": function (exports, module, require) {
				'use strict';

				var forEach = Array.prototype.forEach, create = Object.create;

				var process = function (src, obj) {
					var key;
					for (key in src) obj[key] = src[key];
				};

				module.exports = function (options/*, …options*/) {
					var result = create(null);
					forEach.call(arguments, function (options) {
						if (options == null) return;
						process(Object(options), result);
					});
					return result;
				};
			},
			"valid-value.js": function (exports, module, require) {
				'use strict';

				module.exports = function (value) {
					if (value == null) throw new TypeError("Cannot use null or undefined");
					return value;
				};
			}
		},
		"string": {
			"#": {
				"contains": {
					"index.js": function (exports, module, require) {
						'use strict';

						module.exports = require('./is-implemented')()
							? String.prototype.contains
							: require('./shim');
					},
					"is-implemented.js": function (exports, module, require) {
						'use strict';

						var str = 'razdwatrzy';

						module.exports = function () {
							if (typeof str.contains !== 'function') return false;
							return ((str.contains('dwa') === true) && (str.contains('foo') === false));
						};
					},
					"shim.js": function (exports, module, require) {
						'use strict';

						var indexOf = String.prototype.indexOf;

						module.exports = function (searchString/*, position*/) {
							return indexOf.call(this, searchString, arguments[1]) > -1;
						};
					}
				}
			}
		}
	},
	"es6-symbol": {
		"implement.js": function (exports, module, require) {
			'use strict';

			if (!require('./is-implemented')()) {
				Object.defineProperty(require('es5-ext/global'), 'Symbol',
					{ value: require('./polyfill'), configurable: true, enumerable: false,
						writable: true });
			}
		},
		"is-implemented.js": function (exports, module, require) {
			'use strict';

			var validTypes = { object: true, symbol: true };

			module.exports = function () {
				var symbol;
				if (typeof Symbol !== 'function') return false;
				symbol = Symbol('test symbol');
				try { String(symbol); } catch (e) { return false; }

				// Return 'true' also for polyfills
				if (!validTypes[typeof Symbol.iterator]) return false;
				if (!validTypes[typeof Symbol.toPrimitive]) return false;
				if (!validTypes[typeof Symbol.toStringTag]) return false;

				return true;
			};
		},
		"is-symbol.js": function (exports, module, require) {
			'use strict';

			module.exports = function (x) {
				if (!x) return false;
				if (typeof x === 'symbol') return true;
				if (!x.constructor) return false;
				if (x.constructor.name !== 'Symbol') return false;
				return (x[x.constructor.toStringTag] === 'Symbol');
			};
		},
		"polyfill.js": function (exports, module, require) {
			// ES2015 Symbol polyfill for environments that do not support it (or partially support it)

			'use strict';

			var d              = require('d')
			  , validateSymbol = require('./validate-symbol')

			  , create = Object.create, defineProperties = Object.defineProperties
			  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
			  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)
			  , isNativeSafe;

			if (typeof Symbol === 'function') {
				NativeSymbol = Symbol;
				try {
					String(NativeSymbol());
					isNativeSafe = true;
				} catch (ignore) {}
			}

			var generateName = (function () {
				var created = create(null);
				return function (desc) {
					var postfix = 0, name, ie11BugWorkaround;
					while (created[desc + (postfix || '')]) ++postfix;
					desc += (postfix || '');
					created[desc] = true;
					name = '@@' + desc;
					defineProperty(objPrototype, name, d.gs(null, function (value) {
						// For IE11 issue see:
						// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
						//    ie11-broken-getters-on-dom-objects
						// https://github.com/medikoo/es6-symbol/issues/12
						if (ie11BugWorkaround) return;
						ie11BugWorkaround = true;
						defineProperty(this, name, d(value));
						ie11BugWorkaround = false;
					}));
					return name;
				};
			}());

			// Internal constructor (not one exposed) for creating Symbol instances.
			// This one is used to ensure that `someSymbol instanceof Symbol` always return false
			HiddenSymbol = function Symbol(description) {
				if (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');
				return SymbolPolyfill(description);
			};

			// Exposed `Symbol` constructor
			// (returns instances of HiddenSymbol)
			module.exports = SymbolPolyfill = function Symbol(description) {
				var symbol;
				if (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');
				if (isNativeSafe) return NativeSymbol(description);
				symbol = create(HiddenSymbol.prototype);
				description = (description === undefined ? '' : String(description));
				return defineProperties(symbol, {
					__description__: d('', description),
					__name__: d('', generateName(description))
				});
			};
			defineProperties(SymbolPolyfill, {
				for: d(function (key) {
					if (globalSymbols[key]) return globalSymbols[key];
					return (globalSymbols[key] = SymbolPolyfill(String(key)));
				}),
				keyFor: d(function (s) {
					var key;
					validateSymbol(s);
					for (key in globalSymbols) if (globalSymbols[key] === s) return key;
				}),

				// If there's native implementation of given symbol, let's fallback to it
				// to ensure proper interoperability with other native functions e.g. Array.from
				hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
				isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
					SymbolPolyfill('isConcatSpreadable')),
				iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
				match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
				replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
				search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
				species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
				split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
				toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
				toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
				unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
			});

			// Internal tweaks for real symbol producer
			defineProperties(HiddenSymbol.prototype, {
				constructor: d(SymbolPolyfill),
				toString: d('', function () { return this.__name__; })
			});

			// Proper implementation of methods exposed on Symbol.prototype
			// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
			defineProperties(SymbolPolyfill.prototype, {
				toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
				valueOf: d(function () { return validateSymbol(this); })
			});
			defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
				var symbol = validateSymbol(this);
				if (typeof symbol === 'symbol') return symbol;
				return symbol.toString();
			}));
			defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

			// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
			defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
				d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

			// Note: It's important to define `toPrimitive` as last one, as some implementations
			// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
			// And that may invoke error in definition flow:
			// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
			defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
				d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));
		},
		"validate-symbol.js": function (exports, module, require) {
			'use strict';

			var isSymbol = require('./is-symbol');

			module.exports = function (value) {
				if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
				return value;
			};
		}
	}
})("es6-symbol/implement");
